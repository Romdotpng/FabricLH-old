package lavahack.client.features.module.modules.exploit

import lavahack.client.features.module.Module
import lavahack.client.features.module.enableCallback
import lavahack.client.settings.Setting
import lavahack.client.settings.types.SettingNumber
import lavahack.client.utils.Stopwatch
import lavahack.client.utils.client.interfaces.impl.register
import lavahack.client.utils.client.interfaces.impl.tickListener
import lavahack.client.utils.math.roundToClosest
import lavahack.client.utils.moving
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.util.math.MathHelper
import kotlin.math.floor

@Module.Info(
    name = "CornerClip",
    description = "Phases slightly into the corner of a your surrounding to prevent crystal damage",
    category = Module.Category.EXPLOIT
)
class CornerClip : Module() {
    init {
        val timeout = register(SettingNumber("Timeout", 100L, 20L..200L))
        val autoDisable = register(Setting("Auto Disable", false))

        val stopwatch = Stopwatch()
        var ticks = 0

        fun reset() {
            ticks = 0
            stopwatch.reset()
        }

        enableCallback {
            reset()
        }

        tickListener {
            if(mc.player == null || mc.world == null) {
                reset()

                return@tickListener
            }

            fun checkDisable() {
                if(ticks >= 2 && autoDisable.value) {
                    state = false
                }
            }

            if(moving()) {
                state = false
            } else if(mc.world!!.getBlockCollisions(mc.player, mc.player!!.boundingBox.expand(0.01, 0.0, 0.01)).toList().size < 2) {
                val x = roundToClosest(
                    mc.player!!.x,
                    floor(mc.player!!.x) + 0.301,
                    floor(mc.player!!.x) + 0.699
                )

                val y = mc.player!!.y

                val z = roundToClosest(
                    mc.player!!.z,
                    floor(mc.player!!.z) + 0.301,
                    floor(mc.player!!.z) + 0.699
                )

                mc.player!!.setPosition(x, y, z)

                checkDisable()
            } else if(stopwatch.passed(timeout.value, true)) {
                val y = mc.player!!.y

                val x1 = mc.player!!.x + MathHelper.clamp(
                    roundToClosest(
                        mc.player!!.x,
                        floor(mc.player!!.x) + 0.241,
                        floor(mc.player!!.x) + 0.759
                    ),
                    -0.03,
                    0.03
                )

                val z1 = mc.player!!.z + MathHelper.clamp(
                    roundToClosest(
                        mc.player!!.z,
                        floor(mc.player!!.z) + 0.241,
                        floor(mc.player!!.z) + 0.759
                    ),
                    -0.03,
                    0.03
                )

                val x2 = roundToClosest(
                    mc.player!!.x,
                    floor(mc.player!!.x) + 0.23,
                    floor(mc.player!!.x) + 0.77
                )

                val z2 = roundToClosest(
                    mc.player!!.z,
                    floor(mc.player!!.z) + 0.23,
                    floor(mc.player!!.z) + 0.77
                )

                mc.player!!.setPosition(x1, y, z1)
                mc.networkHandler!!.sendPacket(PlayerMoveC2SPacket.PositionAndOnGround(mc.player!!.x, mc.player!!.y, mc.player!!.z, true))
                mc.networkHandler!!.sendPacket(PlayerMoveC2SPacket.PositionAndOnGround(x2, y, z2, true))

                if(autoDisable.value) {
                    ticks++
                } else {
                    ticks = 0
                }

                checkDisable()
            }
        }
    }
}