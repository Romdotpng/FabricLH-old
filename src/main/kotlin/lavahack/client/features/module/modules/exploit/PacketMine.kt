package lavahack.client.features.module.modules.exploit

import lavahack.client.event.events.ModuleEvent
import lavahack.client.features.module.Module
import lavahack.client.features.module.enableCallback
import lavahack.client.settings.Setting
import lavahack.client.settings.pattern.patterns.BlockPlacerPattern
import lavahack.client.settings.pattern.patterns.SlideRenderingPattern
import lavahack.client.settings.types.SettingEnum
import lavahack.client.settings.types.SettingGroup
import lavahack.client.settings.types.SettingNumber
import lavahack.client.utils.*
import lavahack.client.utils.client.enums.Easings
import lavahack.client.utils.client.enums.InventoryLocations
import lavahack.client.utils.client.enums.ProgressBoxModifiers
import lavahack.client.utils.client.enums.Swaps
import lavahack.client.utils.client.interfaces.impl.*
import lavahack.client.utils.client.ranges.step
import lavahack.client.utils.render.world.SlideRenderer
import net.minecraft.block.Blocks
import net.minecraft.entity.decoration.EndCrystalEntity
import net.minecraft.item.Items
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.network.packet.c2s.play.UpdateSelectedSlotC2SPacket
import net.minecraft.util.Hand
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Direction

/**
 * @author _kisman_
 * @since 10:40 of 04.08.2023
 */
@Module.Info(
    name = "PacketMine",
    description = "Breaks blocks easier.",
    category = Module.Category.EXPLOIT,
    beta = true
)
object PacketMine : Module() {
    var data : Data? = null

    var slot = -1

    val MINING
        get() = data?.progress() != 0.0 && (data?.progress() ?: 1.0) < 1.0

    init {
        displayInfo = {
            if(data == null) ""
            else "${data!!.pos.x} ${data!!.pos.y} ${data!!.pos.z}"
        }

        val await = register(Setting("Await", false))
        val swing = register(Setting("Swing", true))
        val swap = register(Setting("Swap", true))
        val fast = register(Setting("Fast", false))
        val silent = register(Setting("Silent", true))
        val rotate = register(Setting("Rotate", false))
        val strict = register(Setting("Strict", false))
        val rebreak = register(SettingEnum("Rebreak", RebreakModes.None))
        val range = register(SettingNumber("Range", 5.0, 1.0..6.0 step 0.5))

        val renderGroup = register(SettingGroup("Render"))

        val logic = register(renderGroup.add(SettingEnum("Logic", ProgressBoxModifiers.CentredBox)))
        val pattern = register(renderGroup.add(SlideRenderingPattern()))
        val easing = register(renderGroup.add(SettingEnum("Easing", Easings.Linear)))

        val anvilPlacerGroup = register(SettingGroup("Anvils"))
        val anvilPlacerState = register(anvilPlacerGroup.add(Setting("State", false)))
        val anvilPlacerBlocksGroup = register(anvilPlacerGroup.add(SettingGroup("Blocks")))
        val anvilPlacerBlocksObby = register(anvilPlacerBlocksGroup.add(Setting("Obby", true)))
        val anvilPlacerBlocksEnderChest = register(anvilPlacerBlocksGroup.add(Setting("Ender Chest", true)))
        val anvilPlacerBlocksOther = register(anvilPlacerBlocksGroup.add(Setting("Others", true)))
        val anvilPlacer = register(anvilPlacerGroup.add(BlockPlacerPattern(this, this)))

        val crystalPlacerGroup = register(SettingGroup("Crystals"))
        val crystalPlacerState = register(crystalPlacerGroup.add(Setting("State", false)))
        val crystalPlacerOnlyWhenCev = register(crystalPlacerGroup.add(Setting("Only When Cev", false)))
        val crystalPlacerSwap = register(crystalPlacerGroup.add(SettingEnum("Swap", Swaps.Silent)))

        val cevBreakerGroup = register(SettingGroup("Cev Breaker"))
        val cevBreakerState = register(cevBreakerGroup.add(Setting("State", false)))
        //TODO: listeners thing
        val cevBreakerPlacer = register(cevBreakerGroup.add(BlockPlacerPattern(this, this)))


        renderGroup.prefix("Render")
        anvilPlacerGroup.prefix("Anvils")
        crystalPlacerGroup.prefix("Crystals")

        val renderer = SlideRenderer()

        var preplaced = false

        fun reset() {
            preplaced = false

            when(rebreak.valEnum) {
                RebreakModes.None -> {
                    data = null
                }

                RebreakModes.Normal -> {
                    data?.start = System.currentTimeMillis()
                    data?.tries = 0
                }
            }
        }

        enableCallback {
            data = null
            preplaced = false
        }

        tickListener {
            if(mc.player == null || mc.world == null) {
                data = null

                return@tickListener
            }

            slot = if(data == null) -1 else findBestHotbarTool(data!!.pos)

            fun process0(
                data : Data
            ) {
                val pos = data.pos
                val start = data.start
                val allowPreplace = data.allowPreplace
                val block = pos.block()

                val progress = progress(pos, start, slot)

                if(progress > 0.95) {
                    if(allowPreplace && !preplaced) {
                        if(crystalPlacerState.value) {
                            val centre = enemy?.blockPos

                            if(block == Blocks.OBSIDIAN && crystalable(pos, multiplace = false) && (!crystalPlacerOnlyWhenCev.value || (centre != null && pos.cev(centre)))) {
                                val slot = InventoryLocations.Hotbar.findInventoryItem(Items.END_CRYSTAL)
                                val stack = mc.player!!.offHandStack
                                val item = stack.item
                                val offhand = item == Items.END_CRYSTAL
                                val hand = if(offhand) Hand.OFF_HAND else Hand.MAIN_HAND

                                if(slot != -1 || offhand) {
                                    if(!offhand) {
                                        crystalPlacerSwap.valEnum.pre(slot)
                                    }

                                    rightClickBlock(pos, hand = hand, swing = true)

                                    if(!offhand) {
                                        crystalPlacerSwap.valEnum.post()
                                    }

                                    preplaced = true
                                }
                            }
                        }

                        if(anvilPlacerState.value) {
                            if(anvilPlacerBlocksOther.value || (anvilPlacerBlocksObby.value && block == Blocks.OBSIDIAN) || (anvilPlacerBlocksEnderChest.value && block == Blocks.ENDER_CHEST)) {
                                val uppedPos = pos.up()
                                val uppedBlock = uppedPos.block()

                                if(uppedBlock == Blocks.AIR) {
                                    anvilPlacer.place(uppedPos, Items.ANVIL) {
                                        preplaced = true
                                    }
                                }
                            }
                        }
                    }
                }

                if(progress >= 1.0) {
                    val swapper = if(strict.value) {
                        Swaps.StrictSilent
                    } else {
                        Swaps.Silent
                    }

                    if(swap.value) {
                        swapper.pre(slot)
                    }

                    mc.networkHandler!!.sendPacket(PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, data.pos, data.facing))
                    mc.networkHandler!!.sendPacket(PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, data.pos, Direction.UP))

                    if (fast.value) {
                        mc.networkHandler!!.sendPacket(PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, data.pos, data.facing))
                    }

                    mc.networkHandler!!.sendPacket(PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, data.pos, data.facing))

                    if (swap.value && silent.value) {
                        swapper.post()
                    }

                    data.tries++
                }
            }

            fun process1(
                data : Data,
                remover : (Data) -> Unit
            ) {
                //TODO: rebreaks
                if(data.tries > 2) {
                    remover(data)
                }
            }

            fun process2(
                data : Data?
            ) {
                //TODO: rebreaks
                if(data != null && data.pos.block() == Blocks.AIR) {
                    data.rebreaks++
                }
            }

            fun process3(
                data : Data?
            ) {
                /*if(data != null) {
                    val progress = progress(data.pos, data.start, slot)

                    if(progress >= 0.95) {

                    }
                }*/
            }

            if(data != null) {
                /*val pos = data!!.pos

                if()*/

                if(mc.player!!.pos distanceSq data!!.pos.vec() <= range.value * range.value) {
                    process0(data!!)
                    process1(data!!) {
                        val pos = it.pos
                        val centre = enemy?.blockPos

                        reset()

                        if(cevBreakerState.value && (!crystalPlacerOnlyWhenCev.value || (centre != null && pos.cev(centre)))) {
                            if(crystalPlacerState.value) {
                                for(entity in mc.world!!.entities) {
                                    if(entity is EndCrystalEntity) {
                                        val crystalPos = entity.blockPos
                                        val uppedPos = pos.up()

                                        if(crystalPos == uppedPos) {
                                            //TODO: anti weakness
                                            leftClickEntity(entity)
                                        }
                                    }
                                }
                            }

                            cevBreakerPlacer.place(pos, Items.OBSIDIAN)
                        }
                    }
                    process2(data)
                } else {
                    data = null
                    preplaced = false
                }
//                process3(data!!)
            }

            //TODO: rebreaks
        }

        sendListener {
            when(it.packet) {
                is UpdateSelectedSlotC2SPacket -> if(strict.value) {
                    reset()
                }

                is PlayerActionC2SPacket -> {
                    val action = it.packet.action

                    if(action == PlayerActionC2SPacket.Action.START_DESTROY_BLOCK) {
                        val pos = it.packet.pos
                        val block = pos.block()
                        val facing = it.packet.direction

                        if(block.breakable) {
                            data = Data(
                                pos,
                                facing,
                                System.currentTimeMillis(),
                                0,
                                0
                            )
                        }
                    }
                }
            }
        }

        listener<ModuleEvent.PacketMine.ClickBlock> {
            val pos = it.pos
            val direction = it.direction
            val rotates = pos.rotates
            val yaw = rotates.first.toFloat()
            val pitch = rotates.second.toFloat()
//            val allowPreplace = it.allowPreplace


            //TODO: this shit doesnt work ig
            if(rotate.value) {
                mc.networkHandler!!.sendPacket(PlayerMoveC2SPacket.LookAndOnGround(yaw, pitch, mc.player!!.isOnGround))
            }

            mc.player!!.networkHandler.sendPacket(PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, pos, direction))
        }

        worldListener { it0 ->
            val pos = if(data != null) {
                val pos = data!!.pos
                val block = pos.block()

                if(block == Blocks.AIR) {
                    null
                } else {
                    pos
                }
            } else {
                null
            }
            val box = pos?.box()

            renderer.handleRender(it0.matrices, box, pattern) { it1 ->
                if(data != null) {
                    val slot = findBestHotbarTool(data!!.pos)
                    val progress = data!!.progress(slot)
                    val modified = easing.valEnum.inc(progress)

                    logic.valEnum.modifier(it1, modified)
                } else {
                    it1
                }
            }
        }
    }

    fun progress(
        pos : BlockPos,
        start : Long,
        slot : Int
    ) = 1.0 - breakingProgress(pos, mc.player!!.inventory.getStack(slot), start)

    class Data(
        var pos : BlockPos,
        var facing : Direction,
        var start : Long,
        var tries : Int,
        var rebreaks : Int,
        var allowPreplace : Boolean = true
    ) {
        fun progress(
            slot : Int
        ) = progress(pos, start, slot)

        fun progress() = progress(findBestHotbarTool(pos))
    }

    enum class RebreakModes {
        None,
        Normal,
//        Instant
    }
}