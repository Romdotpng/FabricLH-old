package lavahack.client.features.module.modules.exploit

import lavahack.client.features.module.Module
import lavahack.client.features.subsystem.subsystems.rotate
import lavahack.client.settings.Setting
import lavahack.client.settings.types.SettingEnum
import lavahack.client.settings.types.SettingGroup
import lavahack.client.settings.types.SettingNumber
import lavahack.client.utils.*
import lavahack.client.utils.chat.ChatUtility
import lavahack.client.utils.client.enums.Rotates
import lavahack.client.utils.client.interfaces.impl.prefix
import lavahack.client.utils.client.interfaces.impl.register
import lavahack.client.utils.client.interfaces.impl.sendListener
import net.minecraft.item.BlockItem
import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.util.math.MathHelper
import kotlin.math.abs
import kotlin.math.min

@Module.Info(
    name = "RaytraceBypass",
    description = "Oldfashion's stuff",
    category = Module.Category.EXPLOIT
)
class RaytraceBypass : Module() {
    init {
        val debug = register(Setting("Debug", false))
        val ignoreNotFound = register(Setting("Ignore Not Found", false))
        val canSee = register(Setting("Can See", false))
        val mode = register(SettingEnum("Rotations", Rotations.Packet))
        val delay = register(SettingNumber("Delay", 250L, 0L..1000L))
        val multiplier = register(SettingNumber("Multiplier", 100, 5..150))
        val dynamicGroup = register(SettingGroup("Dynamic"))
        val dynamicState = register(dynamicGroup.add(Setting("State", false)))
        val dynamicMin = register(dynamicGroup.add(SettingNumber("Min", 100, 5..150)))
        val dynamicMax = register(dynamicGroup.add(SettingNumber("Max", 100, 5..150)))
        val dynamicStep = register(dynamicGroup.add(SettingNumber("Step", 5, 1..20)))

        dynamicGroup.prefix("Dynamic")

        val stopwatch = Stopwatch()

        var bypassed : Pair<Double, Double>?


        //TODO: check 90 pitch previously
        sendListener {
            fun (Pair<Double, Double>).traceable() : Boolean {
                val eyes = mc.player!!.eyePos
                var look = this.vector

                if(dynamicState.value && dynamicMin.value < dynamicMax.value) {
                    var i = dynamicMin.value

                    while(i < dynamicMax.value) {
                        //TODO: remove it
                        i = min(dynamicMax.value, i)
                        look = eyes.add(look.multiply(i.toDouble()))
                        i += dynamicStep.value

                        if(traceable(eyes, look)) {
                            return true
                        }
                    }

                    return false
                }

                look = eyes.add(look.multiply(multiplier.value.toDouble()))

                return traceable(eyes, look) || ignoreNotFound.value
            }

            fun rotations(
                limit : Double
            ) = if(limit.isNaN()) {
                null
            } else {
                var rotations : Pair<Double, Double>? = null
                var minDiff = Double.MAX_VALUE

                for(yaw in (limit - 5.0)..(limit + 5.0) step 0.5) {
                    for(pitch in -90.0..-40.0 step 0.5) {
                        val diff = abs(limit - yaw)

                        if((rotations == null || diff < minDiff) && (yaw to pitch).traceable()) {
                            rotations = yaw to pitch
                            minDiff = diff
                        }
                    }
                }

                rotations
            }

            val packet = it.packet

            if(packet is PlayerInteractBlockC2SPacket && stopwatch.passed(delay.value, true)) {
                if(!canSee.value || false/*raytracing */) {
                    val result = packet.blockHitResult
                    val pos = result.blockPos
                    val direction = result.side
                    val rotations = pos.rotates(direction)

                    bypassed = rotations(rotations.first)

                    if(debug.value) {
                        if(bypassed == null) {
                            ChatUtility.INFO.print("Rotation is not found")
                        } else {
                            ChatUtility.INFO.print("${bypassed!!.first} ${bypassed!!.second}")
                        }
                    }

                    if(bypassed != null) {
                        bypassed = MathHelper.wrapDegrees(bypassed!!.first) to MathHelper.wrapDegrees(bypassed!!.second)

                        val stack = mc.player!!.mainHandStack
                        val item = stack.item

                        if(item is BlockItem) {
                            //TODO: move into separate method
                            mc.networkHandler!!.sendPacket(PlayerMoveC2SPacket.LookAndOnGround(bypassed!!.first.toFloat(), bypassed!!.second.toFloat(), mc.player!!.isOnGround))
                        } else {
                            //TODO: motion
                            when(mode.valEnum) {
                                Rotations.Internal -> rotate(bypassed!!, Rotates.Normal)
                                Rotations.Packet -> mc.networkHandler!!.sendPacket(PlayerMoveC2SPacket.LookAndOnGround(bypassed!!.first.toFloat(), bypassed!!.second.toFloat(), mc.player!!.isOnGround))
                                else -> { }
                            }
                        }
                    }
                }
            }
        }
    }

    enum class Rotations {
        Motion,
        Packet,
        Internal
    }
}